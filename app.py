import streamlit as st
import json
import sqlite3
import os
import pandas as pd
import io
import base64
from datetime import datetime
import streamlit.components.v1 as components

# Set page configuration
st.set_page_config(
    page_title="Business Category Survey",
    page_icon="üìã",
    layout="wide"
)

# Helper functions for database operations
def get_db_path():
    """Get absolute path to the database file"""
    try:
        # Try to get the directory of the current file
        current_dir = os.path.dirname(os.path.abspath(__file__))
    except:
        # Fall back to current working directory
        current_dir = os.getcwd()
    
    return os.path.join(current_dir, 'survey_data.db')

def execute_query(query, params=None, fetch=False):
    """Execute a SQL query safely with proper error handling"""
    conn = None
    result = None
    
    try:
        db_path = get_db_path()
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
            
        if fetch:
            result = cursor.fetchall()
        else:
            conn.commit()
            result = cursor.lastrowid
            
    except sqlite3.Error as e:
        st.error(f"Database error: {e}")
        if conn:
            conn.rollback()
        return None
        
    finally:
        if conn:
            conn.close()
            
    return result

def init_database():
    """Create database tables if they don't exist"""
    # Create survey_responses table with merchant_name field and location fields
    execute_query('''
    CREATE TABLE IF NOT EXISTS survey_responses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        category TEXT NOT NULL,
        merchant_name TEXT NOT NULL,
        timestamp TEXT NOT NULL,
        latitude TEXT,
        longitude TEXT
    )
    ''')
    
    # Create survey_answers table
    execute_query('''
    CREATE TABLE IF NOT EXISTS survey_answers (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        response_id INTEGER NOT NULL,
        question TEXT NOT NULL,
        answer TEXT NOT NULL,
        FOREIGN KEY (response_id) REFERENCES survey_responses (id)
    )
    ''')
    
    # Test if we can insert and retrieve data
    test_connection()

def test_connection():
    """Test if we can write to and read from the database"""
    try:
        # Test insert
        execute_query(
            "INSERT INTO survey_responses (category, merchant_name, timestamp, latitude, longitude) VALUES (?, ?, ?, ?, ?)",
            ("Test Category", "Test Merchant", "2023-01-01 00:00:00", "0.0", "0.0")
        )
        
        # Test select
        result = execute_query(
            "SELECT id FROM survey_responses WHERE category = ?",
            ("Test Category",),
            fetch=True
        )
        
        if result:
            # Clean up test data
            execute_query(
                "DELETE FROM survey_responses WHERE category = ?",
                ("Test Category",)
            )
            return True
        return False
    except:
        return False

def save_survey(category, merchant_name, answers, latitude=None, longitude=None):
    """Save a survey response to the database"""
    # First insert the survey response
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    response_id = execute_query(
        "INSERT INTO survey_responses (category, merchant_name, timestamp, latitude, longitude) VALUES (?, ?, ?, ?, ?)",
        (category, merchant_name, timestamp, latitude, longitude)
    )
    
    if response_id:
        # Then insert all the answers
        for question, answer in answers.items():
            execute_query(
                "INSERT INTO survey_answers (response_id, question, answer) VALUES (?, ?, ?)",
                (response_id, question, answer)
            )
        return response_id
    return None

def get_recent_responses(limit=10):
    """Get recent survey responses"""
    result = execute_query(
        f"SELECT id, category, merchant_name, timestamp, latitude, longitude FROM survey_responses ORDER BY id DESC LIMIT {limit}",
        fetch=True
    )
    
    if result:
        return [{"id": row[0], "category": row[1], "merchant_name": row[2], "timestamp": row[3], "latitude": row[4], "longitude": row[5]} for row in result]
    return []

def get_response_details(response_id):
    """Get details for a specific response"""
    # Get response info
    response_info = execute_query(
        "SELECT category, merchant_name, timestamp, latitude, longitude FROM survey_responses WHERE id = ?",
        (response_id,),
        fetch=True
    )
    
    if not response_info:
        return None
        
    # Get answers
    answers_result = execute_query(
        "SELECT question, answer FROM survey_answers WHERE response_id = ?",
        (response_id,),
        fetch=True
    )
    
    answers = {row[0]: row[1] for row in answers_result} if answers_result else {}
    
    return {
        "id": response_id,
        "category": response_info[0][0],
        "merchant_name": response_info[0][1],
        "timestamp": response_info[0][2],
        "latitude": response_info[0][3],
        "longitude": response_info[0][4],
        "answers": answers
    }

def get_all_survey_data():
    """Get all survey data for export in a structured format"""
    # Get all survey responses
    responses = execute_query(
        "SELECT id, category, merchant_name, timestamp, latitude, longitude FROM survey_responses",
        fetch=True
    )
    
    if not responses:
        return None
    
    # Prepare data structure
    all_data = []
    
    for response in responses:
        response_id, category, merchant_name, timestamp, latitude, longitude = response
        
        # Get answers for this response
        answers_result = execute_query(
            "SELECT question, answer FROM survey_answers WHERE response_id = ?",
            (response_id,),
            fetch=True
        )
        
        answers = {row[0]: row[1] for row in answers_result} if answers_result else {}
        
        # Add to data structure
        all_data.append({
            "id": response_id,
            "category": category,
            "merchant_name": merchant_name,
            "timestamp": timestamp,
            "latitude": latitude,
            "longitude": longitude,
            "answers": answers
        })
    
    return all_data

# Download helpers
def create_download_link(df, filename, text):
    """Create a download link for a dataframe"""
    csv = df.to_csv(index=False)
    b64 = base64.b64encode(csv.encode()).decode()
    href = f'<a href="data:file/csv;base64,{b64}" download="{filename}">üì• {text}</a>'
    return href

def create_excel_download_link(df, filename, text):
    """Create a download link for an Excel file"""
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Data')
    excel_data = output.getvalue()
    b64 = base64.b64encode(excel_data).decode()
    href = f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="{filename}">üì• {text}</a>'
    return href

def create_json_download_link(data, filename, text):
    """Create a download link for JSON data"""
    json_str = json.dumps(data, ensure_ascii=False, indent=2)
    b64 = base64.b64encode(json_str.encode('utf-8')).decode()
    href = f'<a href="data:file/json;base64,{b64}" download="{filename}">üì• {text}</a>'
    return href

def prepare_survey_dataframe(data):
    """Prepare a flattened dataframe from survey data"""
    # Start with basic info
    rows = []
    
    for item in data:
        row = {
            "ID": item["id"],
            "ÿßŸÑŸÅÿ¶ÿ©": item["category"],
            "ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±": item["merchant_name"],
            "ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸàÿßŸÑŸàŸÇÿ™": item["timestamp"],
            "ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂": item["latitude"],
            "ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ": item["longitude"]
        }
        
        # Add all answers
        for question, answer in item["answers"].items():
            row[question] = answer
        
        rows.append(row)
    
    return pd.DataFrame(rows)

# Function to load the JSON data
@st.cache_data
def load_data():
    try:
        with open('data.json', 'r', encoding='utf-8') as file:
            return json.load(file)
    except FileNotFoundError:
        st.error("Error: data.json file not found in the current directory.")
        return {"business_categories": []}

# Function to get geolocation
def get_location():
    """Get user's geolocation using HTML component"""
    # Create container for location info
    location_container = st.empty()
    
    # Create HTML component with geolocation functionality
    geolocation_html = """
    <div style="margin-bottom: 10px;">
        <button 
            id="get-location-btn" 
            style="background-color: #0366d6; color: white; padding: 10px 16px; 
                   border: none; border-radius: 4px; cursor: pointer; font-weight: bold;"
            onclick="getLocation()">
            üìç ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿ≠ÿßŸÑŸä
        </button>
        <div id="location-status" style="margin-top: 8px; font-size: 14px;"></div>
    </div>
    
    <script>
    function getLocation() {
        // Update status
        document.getElementById('location-status').innerHTML = 
            '<div style="padding: 8px; background-color: #e3f2fd; border-radius: 4px; text-align: right;">ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ...</div>';
        
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    // Success - get coordinates
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    
                    // Save to local storage
                    localStorage.setItem('survey_latitude', lat);
                    localStorage.setItem('survey_longitude', lng);
                    
                    // Update status display
                    document.getElementById('location-status').innerHTML = 
                        '<div style="padding: 8px; background-color: #e8f5e9; border-radius: 4px; text-align: right;">' +
                        'ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿ®ŸÜÿ¨ÿßÿ≠! ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂: ' + lat + ', ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ: ' + lng + '</div>';
                    
                    // Submit coordinates to Streamlit via URL parameters and reload
                    const url = new URL(window.location.href);
                    url.searchParams.set('lat', lat);
                    url.searchParams.set('lng', lng);
                    window.location.href = url.toString();
                },
                function(error) {
                    // Handle errors
                    let errorMessage = 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿ≠ÿßŸàŸÑÿ© ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ.';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = 'ÿ™ŸÖ ÿ±ŸÅÿ∂ ÿ•ÿ∞ŸÜ ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = 'ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©.';
                            break;
                        case error.TIMEOUT:
                            errorMessage = 'ÿßŸÜÿ™Ÿáÿ™ ŸÖŸáŸÑÿ© ÿ∑ŸÑÿ® ÿßŸÑŸÖŸàŸÇÿπ.';
                            break;
                    }
                    document.getElementById('location-status').innerHTML = 
                        '<div style="padding: 8px; background-color: #ffebee; border-radius: 4px; text-align: right;">' +
                        errorMessage + '</div>';
                }
            );
        } else {
            document.getElementById('location-status').innerHTML = 
                '<div style="padding: 8px; background-color: #ffebee; border-radius: 4px; text-align: right;">' +
                'ÿßŸÑŸÖÿ™ÿµŸÅÿ≠ ŸÑÿß ŸäÿØÿπŸÖ ÿÆÿØŸÖÿ© ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ.</div>';
        }
    }
    
    // Check if we have coordinates in localStorage when page loads
    document.addEventListener('DOMContentLoaded', function() {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('lat') && urlParams.has('lng')) {
            // We have coordinates from URL
            const lat = urlParams.get('lat');
            const lng = urlParams.get('lng');
            document.getElementById('location-status').innerHTML = 
                '<div style="padding: 8px; background-color: #e8f5e9; border-radius: 4px; text-align: right;">' +
                'ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿ®ŸÜÿ¨ÿßÿ≠! ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂: ' + lat + ', ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ: ' + lng + '</div>';
        } else {
            // Check localStorage
            const lat = localStorage.getItem('survey_latitude');
            const lng = localStorage.getItem('survey_longitude');
            if (lat && lng) {
                document.getElementById('location-status').innerHTML = 
                    '<div style="padding: 8px; background-color: #e8f5e9; border-radius: 4px; text-align: right;">' +
                    'ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿ≥ÿßÿ®ŸÇŸãÿß! ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂: ' + lat + ', ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ: ' + lng + '</div>';
            }
        }
    });
    </script>
    """
    
    # Render HTML component
    components.html(geolocation_html, height=100)
    
    # Check URL parameters for coordinates
    query_params = st.experimental_get_query_params()
    latitude = None
    longitude = None
    
    if 'lat' in query_params and 'lng' in query_params:
        latitude = query_params['lat'][0]
        longitude = query_params['lng'][0]
        
        # Store in session state
        st.session_state.latitude = latitude
        st.session_state.longitude = longitude
        
        # Clear URL parameters
        cleaned_params = {k: v for k, v in query_params.items() if k not in ['lat', 'lng']}
        st.experimental_set_query_params(**cleaned_params)
        
        # Show map with location
        with location_container:
            st.success(f"ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ: ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂: {latitude}, ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ: {longitude}")
            
            # Show map
            try:
                st.map(pd.DataFrame({
                    'lat': [float(latitude)], 
                    'lon': [float(longitude)]
                }))
            except:
                st.error("ÿ™ÿπÿ∞ÿ± ÿπÿ±ÿ∂ ÿßŸÑÿÆÿ±Ÿäÿ∑ÿ©. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿµÿ≠ÿ© ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™.")
    
    # Alternative manual input
    if st.checkbox("ÿ•ÿØÿÆÿßŸÑ ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ŸäÿØŸàŸäŸãÿß", key="manual_geo_input"):
        col1, col2 = st.columns(2)
        with col1:
            manual_lat = st.text_input("ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂ (Latitude)", key="manual_lat_input")
        with col2:
            manual_lng = st.text_input("ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ (Longitude)", key="manual_lng_input")
            
        if st.button("ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™ ÿßŸÑŸÖÿØÿÆŸÑÿ©", key="use_manual_coords"):
            if manual_lat and manual_lng:
                try:
                    # Validate coordinates
                    lat_float = float(manual_lat)
                    lng_float = float(manual_lng)
                    
                    if -90 <= lat_float <= 90 and -180 <= lng_float <= 180:
                        st.session_state.latitude = manual_lat
                        st.session_state.longitude = manual_lng
                        st.experimental_rerun()
                    else:
                        st.error("ŸÇŸäŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ© ŸÑŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™. Ÿäÿ¨ÿ® ÿ£ŸÜ ŸäŸÉŸàŸÜ ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂ ÿ®ŸäŸÜ -90 Ÿà 90ÿå ŸàÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ ÿ®ŸäŸÜ -180 Ÿà 180.")
                except ValueError:
                    st.error("Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿ£ÿ±ŸÇÿßŸÖ ÿµÿßŸÑÿ≠ÿ© ŸÑŸÑÿ•ÿ≠ÿØÿßÿ´Ÿäÿßÿ™.")
    
    return latitude, longitude

# Initialize the database
init_database()

# Load the data
data = load_data()

# Sidebar navigation
st.sidebar.title("ÿßŸÑŸÇÿßÿ¶ŸÖÿ©")
page = st.sidebar.radio("ÿßÿÆÿ™ÿ± ÿßŸÑÿµŸÅÿ≠ÿ©", ["ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ", "ÿπÿ±ÿ∂ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©", "ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"])

# Extract categories
categories = [category["category"] for category in data["business_categories"]]

# Add information to sidebar
with st.sidebar:
    st.header("ŸÖÿπŸÑŸàŸÖÿßÿ™")
    st.write("Ÿáÿ∞ÿß ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ Ÿäÿ≥ÿßÿπÿØŸÉ ÿπŸÑŸâ ÿßÿÆÿ™Ÿäÿßÿ± ŸÅÿ¶ÿ© ÿßŸÑÿ£ÿπŸÖÿßŸÑ Ÿàÿ™ŸÇÿØŸäŸÖ ÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿπŸÑŸâ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ© ÿßŸÑŸÖÿ™ÿπŸÑŸÇÿ© ÿ®Ÿáÿß.")
    st.write("ÿ≥Ÿäÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿ®ŸäÿßŸÜÿßÿ™ SQLite.")
    
    # Database path info
    if st.checkbox("ÿπÿ±ÿ∂ ŸÖÿπŸÑŸàŸÖÿßÿ™ ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"):
        st.code(f"ŸÖÿ≥ÿßÿ± ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™: {get_db_path()}")
        
        # Test database connection
        if st.button("ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™"):
            if test_connection():
                st.success("ÿ™ŸÖ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠!")
            else:
                st.error("ŸÅÿ¥ŸÑ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™!")

# Main app - Survey Page
if page == "ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ":
    st.title("ÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ ÿßŸÑÿ£ÿπŸÖÿßŸÑ ÿßŸÑÿ™ÿ¨ÿßÿ±Ÿäÿ©")
    st.markdown("### ÿßÿÆÿ™ÿ± ŸÅÿ¶ÿ© ÿßŸÑÿπŸÖŸÑ Ÿàÿ£ÿØÿÆŸÑ ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ± Ÿàÿ£ÿ¨ÿ® ÿπŸÑŸâ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©")

    # Add a select box for categories
    selected_category = st.selectbox("ÿßÿÆÿ™ÿ± ÿßŸÑŸÅÿ¶ÿ©", categories, index=0)
    
    # Add field for merchant name
    merchant_name = st.text_input("ÿ£ÿØÿÆŸÑ ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±", "")
    
    # Get location
    st.subheader("ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ")
    st.markdown("ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑÿ≠ÿßŸÑŸä ŸÑÿ≠ŸÅÿ∏Ÿá ŸÖÿπ ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ.")
    latitude, longitude = get_location()
    
    # Find the selected category data
    selected_category_data = next(
        (category for category in data["business_categories"] if category["category"] == selected_category),
        None
    )

    if selected_category_data:
        st.subheader(f"ÿ£ÿ≥ÿ¶ŸÑÿ© ÿπŸÜ: {selected_category_data['category']}")
        
        # Create a form
        with st.form(key='survey_form'):
            # Dictionary to store answers
            answers = {}
            
            # Display each question with its options
            for i, q in enumerate(selected_category_data["questions"]):
                question = q["question"]
                options = q["options"]
                
                # Create a unique key for each radio button
                key = f"question_{i}"
                
                # Display the question and options
                st.write(f"**{i+1}. {question}**")
                answer = st.radio(
                    "ÿßÿÆÿ™ÿ± ÿ•ÿ¨ÿßÿ®ÿ©",
                    options,
                    key=key,
                    label_visibility="collapsed"
                )
                
                # Add to answers dictionary
                answers[question] = answer
                
                # Add a separator
                st.divider()
            
            # Submit button
            submit_button = st.form_submit_button("ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™")
            
            if submit_button:
                # Validate merchant name
                if not merchant_name:
                    st.error("Ÿäÿ±ÿ¨Ÿâ ÿ•ÿØÿÆÿßŸÑ ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±")
                else:
                    # Get latest location data from session state
                    lat = st.session_state.get('latitude', latitude)
                    lng = st.session_state.get('longitude', longitude)
                    
                    # Save to database
                    response_id = save_survey(selected_category, merchant_name, answers, lat, lng)
                    
                    if response_id:
                        st.success(f"ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠ ŸÅŸä ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿ±ŸÇŸÖ: {response_id}")
                        
                        # Display the answers
                        st.subheader("ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿßŸÑŸÖŸÇÿØŸÖÿ©:")
                        st.write(f"**ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±:** {merchant_name}")
                        
                        # Display location if available
                        if lat and lng:
                            st.write(f"**ÿßŸÑŸÖŸàŸÇÿπ:** ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂: {lat}, ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ: {lng}")
                            
                            # Display map if coordinates are available
                            st.map(pd.DataFrame({'lat': [float(lat)], 'lon': [float(lng)]}))
                        
                        for question, answer in answers.items():
                            st.write(f"**{question}:** {answer}")
                        
                        # Create download links for this survey
                        st.subheader("ÿ™ÿ≠ŸÖŸäŸÑ Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ:")
                        
                        # Prepare data
                        response_data = {
                            "id": response_id,
                            "category": selected_category,
                            "merchant_name": merchant_name,
                            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            "latitude": lat,
                            "longitude": lng,
                            "answers": answers
                        }
                        
                        # Create JSON download
                        json_filename = f"survey_{response_id}_{selected_category.replace(' ', '_')}.json"
                        json_link = create_json_download_link(response_data, json_filename, "ÿ™ÿ≠ŸÖŸäŸÑ ŸÉŸÖŸÑŸÅ JSON")
                        st.markdown(json_link, unsafe_allow_html=True)
                        
                        # Create Excel download
                        df = pd.DataFrame(
                            [[response_id, selected_category, merchant_name, datetime.now().strftime("%Y-%m-%d %H:%M:%S"), lat, lng]], 
                            columns=["ID", "ÿßŸÑŸÅÿ¶ÿ©", "ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±", "ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸàÿßŸÑŸàŸÇÿ™", "ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂", "ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ"]
                        )
                        # Add answers as columns
                        for question, answer in answers.items():
                            df[question] = answer
                        
                        excel_filename = f"survey_{response_id}_{selected_category.replace(' ', '_')}.xlsx"
                        excel_link = create_excel_download_link(df, excel_filename, "ÿ™ÿ≠ŸÖŸäŸÑ ŸÉŸÖŸÑŸÅ Excel")
                        st.markdown(excel_link, unsafe_allow_html=True)
                    else:
                        st.error("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ŸÅÿ∏ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.")
    else:
        st.error("ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑŸÅÿ¶ÿ© ÿßŸÑŸÖÿ≠ÿØÿØÿ©.")

# Results Page
elif page == "ÿπÿ±ÿ∂ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©":
    st.title("ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ©")
    
    # Get recent responses
    recent_responses = get_recent_responses(20)
    
    if not recent_responses:
        st.info("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿßÿ≥ÿ™ÿ®ŸäÿßŸÜÿßÿ™ ÿ≥ÿßÿ®ŸÇÿ©.")
    else:
        st.write(f"ÿπÿØÿØ ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ŸÅŸàÿ∏ÿ©: {len(recent_responses)}")
        
        # Create a table of recent responses
        st.subheader("ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ£ÿÆŸäÿ±ÿ©")
        response_data = {
            "ID": [r["id"] for r in recent_responses],
            "ÿßŸÑŸÅÿ¶ÿ©": [r["category"] for r in recent_responses],
            "ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±": [r["merchant_name"] for r in recent_responses],
            "ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸàÿßŸÑŸàŸÇÿ™": [r["timestamp"] for r in recent_responses],
            "ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂": [r["latitude"] for r in recent_responses],
            "ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ": [r["longitude"] for r in recent_responses]
        }
        st.dataframe(response_data, width=800)
        
        # Allow viewing a specific response
        st.subheader("ÿπÿ±ÿ∂ ÿ™ŸÅÿßÿµŸäŸÑ ÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ")
        response_id = st.number_input("ÿ£ÿØÿÆŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ ŸÑŸÑÿπÿ±ÿ∂", min_value=1, step=1)
        
        if st.button("ÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ"):
            response_details = get_response_details(response_id)
            if response_details:
                col1, col2 = st.columns(2)
                
                with col1:
                    st.write(f"**ÿßŸÑŸÅÿ¶ÿ©:** {response_details['category']}")
                    st.write(f"**ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±:** {response_details['merchant_name']}")
                    st.write(f"**ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸàÿßŸÑŸàŸÇÿ™:** {response_details['timestamp']}")
                    
                    # Display location if available
                    if response_details['latitude'] and response_details['longitude']:
                        st.write(f"**ÿßŸÑŸÖŸàŸÇÿπ:** ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂: {response_details['latitude']}, ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ: {response_details['longitude']}")
                        
                        # Display map
                        st.map(pd.DataFrame({
                            'lat': [float(response_details['latitude'])], 
                            'lon': [float(response_details['longitude'])]
                        }))
                
                with col2:
                    # Download options for this response
                    st.write("**ÿ™ÿ≠ŸÖŸäŸÑ Ÿáÿ∞ÿß ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ:**")
                    
                    # JSON download
                    json_filename = f"survey_{response_id}_{response_details['category'].replace(' ', '_')}.json"
                    json_link = create_json_download_link(response_details, json_filename, "ÿ™ÿ≠ŸÖŸäŸÑ ŸÉŸÖŸÑŸÅ JSON")
                    st.markdown(json_link, unsafe_allow_html=True)
                    
                    # Create dataframe for Excel
                    df = pd.DataFrame(
                        [[
                            response_id, 
                            response_details['category'], 
                            response_details['merchant_name'], 
                            response_details['timestamp'],
                            response_details['latitude'],
                            response_details['longitude']
                        ]], 
                        columns=["ID", "ÿßŸÑŸÅÿ¶ÿ©", "ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±", "ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ŸàÿßŸÑŸàŸÇÿ™", "ÿÆÿ∑ ÿßŸÑÿπÿ±ÿ∂", "ÿÆÿ∑ ÿßŸÑÿ∑ŸàŸÑ"]
                    )
                    # Add answers as columns
                    for question, answer in response_details['answers'].items():
                        df[question] = answer
                    
                    # Excel download
                    excel_filename = f"survey_{response_id}_{response_details['category'].replace(' ', '_')}.xlsx"
                    excel_link = create_excel_download_link(df, excel_filename, "ÿ™ÿ≠ŸÖŸäŸÑ ŸÉŸÖŸÑŸÅ Excel")
                    st.markdown(excel_link, unsafe_allow_html=True)
                
                st.subheader("ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™:")
                for question, answer in response_details["answers"].items():
                    st.write(f"**{question}:** {answer}")
            else:
                st.error(f"ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßÿ≥ÿ™ÿ®ŸäÿßŸÜ ÿ®ÿ±ŸÇŸÖ {response_id}")

# Download Page
elif page == "ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™":
    st.title("ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜÿßÿ™")
    
    # Get all data
    all_data = get_all_survey_data()
    
    if not all_data:
        st.info("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ÿ≠ŸÖŸäŸÑ.")
    else:
        st.write(f"ÿ•ÿ¨ŸÖÿßŸÑŸä ÿπÿØÿØ ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜÿßÿ™: {len(all_data)}")
        
        st.subheader("ÿ™ÿ≠ŸÖŸäŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™")
        
        # Format selection
        format_option = st.radio(
            "ÿßÿÆÿ™ÿ± ÿµŸäÿ∫ÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ:",
            ["Excel (ŸÖŸÑŸÅ Ÿàÿßÿ≠ÿØ)", "CSV (ŸÖŸÑŸÅ Ÿàÿßÿ≠ÿØ)", "JSON (ŸÖŸÑŸÅ Ÿàÿßÿ≠ÿØ)"]
        )
        
        # Create timestamp for filenames
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        if format_option == "Excel (ŸÖŸÑŸÅ Ÿàÿßÿ≠ÿØ)":
            # Create a flattened dataframe
            df = prepare_survey_dataframe(all_data)
            
            # Create the download link
            excel_filename = f"all_surveys_{timestamp}.xlsx"
            excel_link = create_excel_download_link(df, excel_filename, "ÿ™ÿ≠ŸÖŸäŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÉŸÖŸÑŸÅ Excel")
            st.markdown(excel_link, unsafe_allow_html=True)
            
        elif format_option == "CSV (ŸÖŸÑŸÅ Ÿàÿßÿ≠ÿØ)":
            # Create a flattened dataframe
            df = prepare_survey_dataframe(all_data)
            
            # Create the download link
            csv_filename = f"all_surveys_{timestamp}.csv"
            csv_link = create_download_link(df, csv_filename, "ÿ™ÿ≠ŸÖŸäŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÉŸÖŸÑŸÅ CSV")
            st.markdown(csv_link, unsafe_allow_html=True)
            
        else:  # JSON
            # Create the download link
            json_filename = f"all_surveys_{timestamp}.json"
            json_link = create_json_download_link(all_data, json_filename, "ÿ™ÿ≠ŸÖŸäŸÑ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÉŸÖŸÑŸÅ JSON")
            st.markdown(json_link, unsafe_allow_html=True)
        
        # Filter options
        st.subheader("ÿ™ÿµŸÅŸäÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ≠ÿ≥ÿ® ÿßŸÑŸÅÿ¶ÿ©")
        
        # Get unique categories
        unique_categories = list(set(item["category"] for item in all_data))
        
        selected_category = st.selectbox(
            "ÿßÿÆÿ™ÿ± ÿßŸÑŸÅÿ¶ÿ© ŸÑŸÑÿ™ÿ≠ŸÖŸäŸÑ",
            unique_categories
        )
        
        # Filter data by category
        filtered_data = [item for item in all_data if item["category"] == selected_category]
        
        if filtered_data:
            st.write(f"ÿπÿØÿØ ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜÿßÿ™ ŸÅŸä ÿßŸÑŸÅÿ¶ÿ© '{selected_category}': {len(filtered_data)}")
            
            # Create download links for filtered data
            df_filtered = prepare_survey_dataframe(filtered_data)
            
            # Excel download
            excel_filename = f"{selected_category.replace(' ', '_')}_{timestamp}.xlsx"
            excel_link = create_excel_download_link(df_filtered, excel_filename, f"ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ '{selected_category}' ŸÉŸÖŸÑŸÅ Excel")
            st.markdown(excel_link, unsafe_allow_html=True)
            
            # CSV download
            csv_filename = f"{selected_category.replace(' ', '_')}_{timestamp}.csv"
            csv_link = create_download_link(df_filtered, csv_filename, f"ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ '{selected_category}' ŸÉŸÖŸÑŸÅ CSV")
            st.markdown(csv_link, unsafe_allow_html=True)
            
            # JSON download
            json_filename = f"{selected_category.replace(' ', '_')}_{timestamp}.json"
            json_link = create_json_download_link(filtered_data, json_filename, f"ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ '{selected_category}' ŸÉŸÖŸÑŸÅ JSON")
            st.markdown(json_link, unsafe_allow_html=True)
            
        # Filter options by merchant name
        st.subheader("ÿ™ÿµŸÅŸäÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ≠ÿ≥ÿ® ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ±")
        
        # Get unique merchant names
        unique_merchants = list(set(item["merchant_name"] for item in all_data))
        
        selected_merchant = st.selectbox(
            "ÿßÿÆÿ™ÿ± ÿßÿ≥ŸÖ ÿßŸÑÿ™ÿßÿ¨ÿ± ŸÑŸÑÿ™ÿ≠ŸÖŸäŸÑ",
            unique_merchants
        )
        
        # Filter data by merchant name
        filtered_by_merchant = [item for item in all_data if item["merchant_name"] == selected_merchant]
        
        if filtered_by_merchant:
            st.write(f"ÿπÿØÿØ ÿßŸÑÿßÿ≥ÿ™ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ÿßÿ¨ÿ± '{selected_merchant}': {len(filtered_by_merchant)}")
            
            # Create download links for filtered data
            df_filtered_merchant = prepare_survey_dataframe(filtered_by_merchant)
            
            # Excel download
            excel_filename = f"merchant_{selected_merchant.replace(' ', '_')}_{timestamp}.xlsx"
            excel_link = create_excel_download_link(df_filtered_merchant, excel_filename, f"ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿßÿ¨ÿ± '{selected_merchant}' ŸÉŸÖŸÑŸÅ Excel")
            st.markdown(excel_link, unsafe_allow_html=True)
            
            # CSV download
            csv_filename = f"merchant_{selected_merchant.replace(' ', '_')}_{timestamp}.csv"
            csv_link = create_download_link(df_filtered_merchant, csv_filename, f"ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿßÿ¨ÿ± '{selected_merchant}' ŸÉŸÖŸÑŸÅ CSV")
            st.markdown(csv_link, unsafe_allow_html=True)
            
            # JSON download
            json_filename = f"merchant_{selected_merchant.replace(' ', '_')}_{timestamp}.json"
            json_link = create_json_download_link(filtered_by_merchant, json_filename, f"ÿ™ÿ≠ŸÖŸäŸÑ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ™ÿßÿ¨ÿ± '{selected_merchant}' ŸÉŸÖŸÑŸÅ JSON")
            st.markdown(json_link, unsafe_allow_html=True)